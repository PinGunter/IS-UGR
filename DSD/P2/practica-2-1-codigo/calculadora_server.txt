/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"

double *
sumar_1_svc(pareja_double arg1, struct svc_req *rqstp)
{
	static double result;
	result = arg1.num1 + arg1.num2;
	printf("Haciendo suma de %f con %f\n", arg1.num1, arg1.num2);
	return &result;
}

double *
restar_1_svc(pareja_double arg1, struct svc_req *rqstp)
{
	static double result;
	result = arg1.num1 - arg1.num2;
	printf("Haciendo resta de %f con %f\n", arg1.num1, arg1.num2);
	return &result;
}

double *
multiplicar_1_svc(pareja_double arg1, struct svc_req *rqstp)
{
	static double result;
	result = arg1.num1 * arg1.num2;
	printf("Haciendo producto de %f con %f\n", arg1.num1, arg1.num2);
	return &result;
}

double *
dividir_1_svc(pareja_double arg1, struct svc_req *rqstp)
{
	static double result;
	if (arg1.num2 != 0.0)
	{
		result = arg1.num1 / arg1.num2;
		printf("Haciendo division de %f con %f\n", arg1.num1, arg1.num2);
	}
	else
	{
		printf("No se puede dividir por 0\n");
	}
	return &result;
}

int *divisionentera_1_svc(pareja_int arg1, struct svc_req *rqstp)
{
	static int result;
	if (arg1.num2 != 0)
	{
		result = (int)arg1.num1 / (int)arg1.num2;
		printf("Haciendo division entera de %i con %i\n", arg1.num1, arg1.num2);
	}
	else
	{
		printf("No se puede dividir por 0\n");
	}
	return &result;
}

int *modulo_1_svc(pareja_int arg1, struct svc_req *rqstp)
{
	static int result;
	if (arg1.num2 != 0)
	{
		result = (int)arg1.num1 % (int)arg1.num2;
		printf("Haciendo modulo de %i con %i\n", arg1.num1, arg1.num2);
	}
	else
	{
		printf("No se puede dividir por 0\n");
	}
	return &result;
}

vec3 *
sumavec3_1_svc(pareja_vec3 arg1, struct svc_req *rqstp)
{
	static vec3 result;
	result.x = arg1.v1.x + arg1.v2.x;
	result.y = arg1.v1.y + arg1.v2.y;
	result.z = arg1.v1.z + arg1.v2.z;
	printf("Sumando vectores\n");
	return &result;
}

vec2 *
sumavec2_1_svc(pareja_vec2 arg1, struct svc_req *rqstp)
{
	static vec2 result;
	result.x = arg1.v1.x + arg1.v2.x;
	result.y = arg1.v1.y + arg1.v2.y;
	printf("Sumando vectores\n");
	return &result;
}

vec3 *
restavec3_1_svc(pareja_vec3 arg1, struct svc_req *rqstp)
{
	static vec3 result;
	result.x = arg1.v1.x - arg1.v2.x;
	result.y = arg1.v1.y - arg1.v2.y;
	result.z = arg1.v1.z - arg1.v2.z;
	printf("Restando vectores\n");	
	return &result;
}

vec2 *
restavec2_1_svc(pareja_vec2 arg1, struct svc_req *rqstp)
{
	static vec2 result;
	result.x = arg1.v1.x - arg1.v2.x;
	result.y = arg1.v1.y - arg1.v2.y;
	printf("Restando vectores\n");
	return &result;
}

vec2 *
pescalar2_1_svc(vec2escalar arg1, struct svc_req *rqstp)
{
	static vec2 result;
	result.x = arg1.escalar * arg1.v.x;
	result.y = arg1.escalar * arg1.v.y;
	printf("Producto escalar\n");
	return &result;
}

vec3 *
pescalar3_1_svc(vec3escalar arg1, struct svc_req *rqstp)
{
	static vec3 result;
	result.x = arg1.escalar * arg1.v.x;
	result.y = arg1.escalar * arg1.v.y;
	result.z = arg1.escalar * arg1.v.z;
	printf("Producto escalar\n");
	return &result;
}
